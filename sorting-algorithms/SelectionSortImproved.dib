#!meta

{"kernelInfo":{"defaultKernelName":"csharp","items":[{"aliases":[],"name":"csharp"}]}}

#!csharp

int[] arr = [99, 44, 6, 2, 1, 5, 63, 87, 283, 4, 0];

public (int[] ResultArr, long Loops, long Steps) SelectionSort(int[] arr, long Loops = 0, long Steps = 0) {
    for(int i = 0; i < arr.Length; i++) {
        int minIndex = i;
        for(int j = i + 1; j < arr.Length; j++) {
            if (arr[j] < arr[minIndex]) {
                minIndex = j;
            }
        Steps++;
        }
        int temp = arr[i];
        arr[i] = arr[minIndex];
        arr[minIndex] = temp;
        Loops++;
    }

    return (arr, Loops, Steps);
}
public (int[] ResultArr, long Loops, long Steps)  SelectionSortImproved(int[] arr, long Loops = 0, long Steps = 0) {
    long loops = Loops;
    long steps = Steps;
    int length = arr.Length;
    int swaps = 0;
   for(int i = 0; i < length; i++) {
       // check full array from start to finish and back
       int leadingPointerUp1 = i + 1 > length - 1 ? i : i + 1;
       int leadingPointerUp2 = i + 2 > length - 1 ? i : i + 2;       
       int leadingPointerUp3 = i + 3 > length - 1 ? i : i + 3;
       int leadingPointerUp4 = i + 4 > length - 1 ? i : i + 4;
       int leadingPointerUp5 = i + 5 > length - 1 ? i : i + 5;
       if(arr[i] > arr[leadingPointerUp1]) {
            int temp = arr[i];
            arr[i] = arr[leadingPointerUp1];
            arr[leadingPointerUp1] = temp;
            swaps++;
        }
        if(arr[i] > arr[leadingPointerUp2]) {
            int temp = arr[i];
            arr[i] = arr[leadingPointerUp2];
            arr[leadingPointerUp2] = temp;
            swaps++;
        }
        if(arr[i] > arr[leadingPointerUp3]) {
            int temp = arr[i];
            arr[i] = arr[leadingPointerUp3];
            arr[leadingPointerUp3] = temp;
            swaps++;
        }
        if(arr[i] > arr[leadingPointerUp4]) {
            int temp = arr[i];
            arr[i] = arr[leadingPointerUp4];
            arr[leadingPointerUp4] = temp;
            swaps++;
        }
        if(arr[i] > arr[leadingPointerUp5]) {
            int temp = arr[i];
            arr[i] = arr[leadingPointerUp5];
            arr[leadingPointerUp5] = temp;
            swaps++;
        }
        int leadingPointerDown1 = length - i - 2 >= 0 ? length - i - 2 : length - i - 1;
        int leadingPointerDown2 = length - i - 3 >= 0 ? length - i - 3 : length - i - 1;
        int leadingPointerDown3 = length - i - 4 >= 0 ? length - i - 4 : length - i - 1;
        int leadingPointerDown4 = length - i - 5 >= 0 ? length - i - 5 : length - i - 1;
        int leadingPointerDown5 = length - i - 6 >= 0 ? length - i - 6 : length - i - 1;
        if(arr[length - i - 1] < arr[leadingPointerDown1]) {
            int temp = arr[length - i - 1];
            arr[length - i - 1] = arr[leadingPointerDown1];
            arr[leadingPointerDown1] = temp;
            swaps++;
        }
        if(arr[length - i - 1] < arr[leadingPointerDown2]) {
            int temp = arr[length - i - 1];
            arr[length - i - 1] = arr[leadingPointerDown2];
            arr[leadingPointerDown2] = temp;
            swaps++;
        }
        if(arr[length - i - 1] < arr[leadingPointerDown3]) {
            int temp = arr[length - i - 1];
            arr[length - i - 1] = arr[leadingPointerDown3];
            arr[leadingPointerDown3] = temp;
            swaps++;
        }
        if(arr[length - i - 1] < arr[leadingPointerDown4]) {
            int temp = arr[length - i - 1];
            arr[length - i - 1] = arr[leadingPointerDown4];
            arr[leadingPointerDown4] = temp;
            swaps++;
        }
        if(arr[length - i - 1] < arr[leadingPointerDown5]) {
            int temp = arr[length - i - 1];
            arr[length - i - 1] = arr[leadingPointerDown5];
            arr[leadingPointerDown5] = temp;
            swaps++;
        }
        // check middle to upper bound
        int midian = length / 2;
        int upperLimitMid = midian + i > length - 1 ? length - 1 : midian + i;
        int upperLimitMidPlus1 = upperLimitMid + 1 > length - 1 ? length - 1 : midian + i;
        int upperLimitMidPlus2 = upperLimitMid + 2 > length - 1 ? length - 1 : midian + i;
        int upperLimitMidPlus3 = upperLimitMid + 3 > length - 1 ? length - 1 : midian + i;
        int upperLimitMidPlus4 = upperLimitMid + 4 > length - 1 ? length - 1 : midian + i;
        int upperLimitMidPlus5 = upperLimitMid + 5 > length - 1 ? length - 1 : midian + i;
        if (arr[upperLimitMid] > arr[upperLimitMidPlus1]) {
            int temp = arr[upperLimitMid];
            arr[upperLimitMid] = arr[upperLimitMidPlus1];
            arr[upperLimitMidPlus1] = temp;
            swaps++;
        }
        if (arr[upperLimitMid] > arr[upperLimitMidPlus2]) {
            int temp = arr[upperLimitMid];
            arr[upperLimitMid] = arr[upperLimitMidPlus2];
            arr[upperLimitMidPlus2] = temp;
            swaps++;
        }
        if (arr[upperLimitMid] > arr[upperLimitMidPlus3]) {
            int temp = arr[upperLimitMid];
            arr[upperLimitMid] = arr[upperLimitMidPlus3];
            arr[upperLimitMidPlus3] = temp;
            swaps++;
        }
        if (arr[upperLimitMid] > arr[upperLimitMidPlus4]) {
            int temp = arr[upperLimitMid];
            arr[upperLimitMid] = arr[upperLimitMidPlus4];
            arr[upperLimitMidPlus4] = temp;
            swaps++;
        }
        if (arr[upperLimitMid] > arr[upperLimitMidPlus5]) {
            int temp = arr[upperLimitMid];
            arr[upperLimitMid] = arr[upperLimitMidPlus5];
            arr[upperLimitMidPlus5] = temp;
            swaps++;
        }
        // check middle to lower bound
        int lowerLimitMid = midian - i < 0 ? 0 : midian - i;
        int lowerLimitMidMinus1 = lowerLimitMid - 1 < 0 ? 0 : lowerLimitMid;
        int lowerLimitMidMinus2 = lowerLimitMid - 2 < 0 ? 0 : lowerLimitMid;
        int lowerLimitMidMinus3 = lowerLimitMid - 3 < 0 ? 0 : lowerLimitMid;
        int lowerLimitMidMinus4 = lowerLimitMid - 4 < 0 ? 0 : lowerLimitMid;
        int lowerLimitMidMinus5 = lowerLimitMid - 5 < 0 ? 0 : lowerLimitMid;
        if (arr[lowerLimitMidMinus1] > arr[lowerLimitMid]) {
            int temp = arr[lowerLimitMidMinus1];
            arr[lowerLimitMidMinus1] = arr[lowerLimitMid];
            arr[lowerLimitMid] = temp;
            swaps++;
        }
        if (arr[lowerLimitMidMinus2] > arr[lowerLimitMid]) {
            int temp = arr[lowerLimitMidMinus2];
            arr[lowerLimitMidMinus2] = arr[lowerLimitMid];
            arr[lowerLimitMid] = temp;
            swaps++;
        }
        if (arr[lowerLimitMidMinus3] > arr[lowerLimitMid]) {
            int temp = arr[lowerLimitMidMinus3];
            arr[lowerLimitMidMinus3] = arr[lowerLimitMid];
            arr[lowerLimitMid] = temp;
            swaps++;
        }
        if (arr[lowerLimitMidMinus4] > arr[lowerLimitMid]) {
            int temp = arr[lowerLimitMidMinus4];
            arr[lowerLimitMidMinus4] = arr[lowerLimitMid];
            arr[lowerLimitMid] = temp;
            swaps++;
        }
        if (arr[lowerLimitMidMinus5] > arr[lowerLimitMid]) {
            int temp = arr[lowerLimitMidMinus5];
            arr[lowerLimitMidMinus5] = arr[lowerLimitMid];
            arr[lowerLimitMid] = temp;
            swaps++;
        }
    }
    steps++;
    loops++;
    if(swaps == 0)
    { 
        return (arr, loops, steps);
    }
    else
    {
        return SelectionSortImproved(arr, loops, steps);
    }
}
Console.WriteLine($"Array - {string.Join(",", arr)}");
(int[] ResultArr, long Loops, long Steps) = SelectionSort(arr, 0, 0);
Console.WriteLine($"Length - {ResultArr.Length} / BigON - {ResultArr.Length*ResultArr.Length} / Steps - {Steps} / Loops - {Loops} / Array - {string.Join(",", ResultArr)}");
(int[] ResultArr2, long Loops2, long Steps2) = SelectionSortImproved(arr, 0, 0);
Console.WriteLine($"Length - {ResultArr2.Length} / BigON - {ResultArr2.Length*ResultArr2.Length} / Steps - {Steps2} / Loops - {Loops2} / Array - {string.Join(",", ResultArr2)}");

#!javascript

let arr = [99, 44, 6, 2, 1, 5, 63, 87, 283, 4, 0];

const selectionSort = (arr) => {
    let loops = 0;
    let steps = 0;
    let length = arr.length;
    for (let i = 0; i < length; i++) {
        let minIndex = i;
        for (let j = i + 1; j < length; j++) {
            if (arr[j] < arr[minIndex]) {
                minIndex = j;
            }
            steps++;
        }
        let temp = arr[i];
        arr[i] = arr[minIndex];
        arr[minIndex] = temp;
        loops++;
    }
    return { resultArr: arr, loops, steps };
}

const selectionSortImproved = (arr) => {
    let loops = 0;
    let steps = 0;
    let length = arr.length;
    let swaps = 0;
    for (let i = 0; i < length; i++) {
        let indices = Array.from({ length: 6 }, (_, k) => i + k)
            .concat(Array.from({ length: 6 }, (_, k) => length - i - 1 - k))
            .filter(index => index >= 0 && index < length);
        indices.forEach(index => {
            if (i !== index) {
                if (i < index && arr[i] > arr[index] || i > index && arr[i] < arr[index]) {
                    let temp = arr[i];
                    arr[i] = arr[index];
                    arr[index] = temp;
                    swaps++;
                }
            }
        });
        steps++;
        loops++;
    }
    if (swaps === 0) {
        return { resultArr: arr, loops, steps };
    } else {
        return selectionSortImproved(arr); // Note: Recursive calls might lead to maximum call stack size exceeded
    }
}

// Testing the sorting functions
let sortedArr = selectionSort([...arr]);
console.log(`Array - ${sortedArr.resultArr}`);
console.log(`Length - ${sortedArr.resultArr.length} / BigON - ${Math.pow(sortedArr.resultArr.length, 2)} / Steps - ${sortedArr.steps} / Loops - ${sortedArr.loops} / Array - ${sortedArr.resultArr}`);

let sortedArr2 = selectionSortImproved([...arr]);
console.log(`Length - ${sortedArr2.resultArr.length} / BigON - ${Math.pow(sortedArr2.resultArr.length, 2)} / Steps - ${sortedArr2.steps} / Loops - ${sortedArr2.loops} / Array - ${sortedArr2.resultArr}`);
